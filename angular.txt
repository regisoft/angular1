
------------------------------------------------------------------------pre requirements
https://angular.io/tutorial
https://nodejs.org/en/download/

npm -v
node -v

npm install npm@latest -g.
npm audit --help

nvm list
---bringt nichts
--dont-- nvm uninstall 4.6.0
--dont-- nvm install v10.11.0 64
--dont-- npm install -g npm

npm install
npm start ... macht    ng serve
CLI (==ng) is based on Webpack = bundles js, css usw.
ng serve -sucht-> angular.js -darin-> Main.ts -bootstrapModule-> app_module.ts -darin bootstrap-> app.component.ts (renders the rest)

ng generate component gugus .... you have to put in a declarations in NgModules

-----------------------from scratch
ng new client
npm install bootstrap in angular.js -> styles -> "node_modules/bootstrap/dist/css/bootstrap.min.css"



-----------------------basic
AppModule = component to use as the top-level component (normaly AppComponent)

NgModule = ist auch decorator/metadata für class == wrapper loader für components wie package ... das  declarations darin ist wie header-File

page = application shell = The shell is controlled by an Angular component named AppComponent

template als url oder direkt als string (=keine intellisense..)

@Component == Das "@" is typescript nicht angular und ist in c# annotation for class / decorator function  /   in A-js war component eine direktive / neue Tags für Browser
selector = custom-html-Tag-Name

Application = tree of Components

Erstellreihenfolge:
Models -> Services -> Views
Pulling data out of our components and into services helps a lot. 
At least if services are the “owners” of our data
 
Names:
Klasse = ChatThreadComponent
Filename = chat-thread.component.ts/html
Selector = chat-thread 

Zugriff auf DOM (ausserhalb):.. nativeElement.querySelector('.msg-container-base')


----------------------model
models in dem unterdordner woe die View ist
import { Article } from './article.model';
hat auch funcs wie voteUp()... wird dann auferufen von voteUp der Komponente



---------------------------input/output
*ngFor   (war früher ng-repeat)    <li *ngFor="let name of names; let i=index">  <app-user-item [name]="name">
<app-article *ngFor="let foo of sortedArticles()" [article]="foo"    (onProductSelected)="productWasSelected($event)">   
 .... [article] ist ein Input() von app-article  ...pass data into child components
 .... (onProductSelected) ist ein Output() von app-article ...we want to listen to the onProductSelected output from child component

@Input() foo: string;   In TS  == Input annotation == pass data into the child component 
[foo] In HTML == pass a value to the input named foo on that component
[class.selected]="isSelected(myProduct)"    ....add the CSS class "selected" if isSelected(myProduct) returns true

@Output() onProductSelected: EventEmitter<Product>;   In TS
<button (click)="increase()">   binding the click output of the button  
prinzipiell:    (output)="action()"
EventEmitter== an object that helps you implement the Observer Pattern = 1. maintain a list of subscribers 2. publish events to them. / subscribe+emit ... angualr sbscribe selber
this.onProductSelected.emit(product);

(keydown.enter)="onEnter($event)"  .... onEnter(event: any): void { this.sendMessage(); event.preventDefault(); }

@Output() results: EventEmitter<SearchResult[]> = new EventEmitter<SearchResult[]> ();

| = pipe z.B. uppercase
{{ = template tags (or sometimes mustache tags interpolation) = property anzeigen


[(ngModel)] = 2 way bind ... Sollte heute nicht mehr geamcht werden..
heute:  one-way data binding. That is, your data flows only down through components. If you need to make changes, you emit events that cause changes to happen “at the top” 
As long as the side-effects are kept local to the component... 2 way OK


----------------------binds...
<form><label for="foo"/><input name="foo" id="title" #newFoo>   ... foo ist ein input tag
# ist eine template variable... to assign those tags to a local variable

<button (click)="addArticle(newFoo)

anderes Bsp:
  <input type="text" name="color" value="{{color}}" #colorinput>
  <button (click)="apply(colorinput.value, fontinput.value)">

<a href (click)="voteDown()">
 return a boolean value of false (tells the browser not to propagate the event upwards... == not refresh page)

addArticle(title: HTMLInputElement

@HostBinding('attr.class') cssClass = 'row';     host is the element this component is attached to.  we’re able to configure our host element from within the component.
@HostListener  this decorator allows a directive to listen to events on its host element.
constructor(_elementRef: ElementRef) {  (_elementRef.nativeElement  ... Zugriff auf draussen



-----------------------client side routing
//something/#/about   ...das ist hash-based routing
neu mit html 5 nicht mehr nötig... jetzt   history.pushState
routes gebrauchen indem das in NgModule:  RouterModule.forRoot(
x routes im gleichen Module
basiert auf folgendem Provider:   { provide: LocationStrategy, ...
ID in url entgegennehmen als constructor param:  private route: ActivatedRoute   ...dann auslesen in ngOnInit()... {  this.contractId = +this.route.snapshot.paramMap.get('id');
queryParam in URL setzen von controller aus:   this.router.navigate(['search'], { queryParams: { query: query } }).then(_ => this.search() );
canActivate: [ LoggedInGuard ]   als route params für Authentication... a form of user-experience and not one of security... Security muss auf Server

[routerLink] ersetzt dann Inhalt von folgendem
<router-outlet> where the contents of each route component will be rendered.



-----------------------Lifecycle Hooks
• OnInit
• OnDestroy
• DoCheck
• OnChanges
• AfterContentInit
• AfterContentChecked
• AfterViewInit
• AfterViewChecked
.... das ist abschliessend



-----------------------ts typescript... js-reference
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
https://www.typescriptlang.org/play/

"tsun" ist REPL in command line für TS

Mit folgendem kann man ts File im Ts-Node ausführen lassen:
./node_modules/.bin/ts-node [filename]
 
ES6 kann classes und Modules
ts fügt types und annotations zu ES6 hinzu
nach build ist alles ES5

backticks `   ist ES6 = multiline strings

private geht auch
Everything in a class is public if not specified. 

Module == .NET namespaces

this.articles.push(new Article(tit
articles.sort((a: Article, b: Article) => b.votes - a.votes);   das ist ES6 (Fat arrow functions)... ananyome function lambda 

---geht beides
var jobs: Array<string> = ['IBM', 'Microsoft', 'Google'];
var jobs: string[] = ['Apple', 'Dell', 'HP'];
this.products = [];

 `Hello ${lastName}`; .. das ist TS nicht angular

constructor(obj?: any) {
  this.id = obj && obj.id || null;

Möglichst wenig in constructor... mehr in OnInit ... testable code, minimize the side effects of constructing an object

constructor(public name: string ...= Shorthand direkt property
    






-----------------------Built-in Directives
NgIf
NgSwitch
NgStyle
NgClass
NgFor
NgNonBindable ...html.raw
<pre> tag  für Data oder Code Darstellung

-----------------------css und styling
https://semantic-ui.com/modules/tab.html#/examples

Bootstrap Sass kommt rein mit  "npm install bootstrap"
in angular.js  refernezizeirt... "styles": ["src/styles.scss"  ],
in styles.scss  ... im root referenziert es dann 

https://loiane.com/2017/08/how-to-add-bootstrap-to-an-angular-cli-project/



-----------------------Form
https://angular.io/guide/forms-overview

--FormControl = single input field
errors, dirty, valid

--FormGroup

ngForm
man kann auch normales <form> brauchen und submit func holt sich vars aus form

“reactive” Elemente im COntroller zusammenbasteln ...FormBuilder ... hat [formGroup]
“template” wie gehabt


Wenn man FormsModule importiert hängt es sich an jedes <form> tag und gibt
A FormGroup named ngForm
2. A (ngSubmit) output

<form #f="ngForm" (ngSubmit)="onSubmit(f.value)"    .... when I submit the form, call onSubmit on my component instance and pass the value of the form as the argument
onSubmit(form: any): void { ..}

  
--gross/klein
NgModel = class, object
ngModel = selector of the directive

NgModel is the directive that you use in your view
FormControl is the object used for representing the data and validations in your form

To create a new FormGroup and FormControls implicitly use: • ngForm and • ngModel
But to bind to an existing FormGroup and FormControls use: • formGroup and • formControl

--ngModel ... creates a new FormControl that is automatically added to the parent FormGroup
ist special weil 2 way
 <input type="text" ngModel>  ...ohne weitere Angabe dann one-way
 [(ngModel)]="productName" ...2 way

 <input type="text" [formControl]="myForm.controls.sku">



----------------------DI Dependency Injection
inject something by creating an argument in the constructor
share a single instance of the B class across our whole app

export interface IPriceService {...}
export class MockPriceService implements IPriceService {...}
constructor(service: IPriceService...

Angualr hat DependencRegistiry .. braucht
1. the token to use to refer this injectable dependency
2. the way to inject the dependency


@Injectable() Anotation... before export class...

in NgModule providers: [ UserService    ...dann...     constructor(private userService: UserService)  ...dann verwenden auch ausserhalb contructor...  this.userService.setUser
Every class that injects the UserService will receive the same singleton... angular kreeirt ihn

providers kann...
• Inject a (singleton) instance of a class (as we’ve seen)
• Inject a value ... { provide: 'API_URL', useValue: 'http://my.api.com/v1' }
• Call any function and inject the return value of that function

Man kann die Injectibales auch auslagern in Klasse  und dann so in NgModule einbinden:   providers: [ youTubeServiceInjectables ]

constructor(   @Inject(YOUTUBE_API_KEY) private apiKey:

-----------------------REST http
consume in core RestSharp:   https://github.com/restsharp/RestSharp/wiki/Getting-Started


-----------------------observable rxjs
Observables to structure our data is called Reactive Programming
sind streams

promises (nicht brauchen) emit a single value whereas streams emit many values
callbacks sind noch älter als promises

es pusht (nicht pull)
Think of streams like a pipeline of operations over your data. You can subscribe to any part of your stream and even combine them to create new streams

// a stream that publishes new messages only once ... Subject is a rxjs keyword ...supports “read/write”
newMessages: Subject<Message> = new Subject<Message>();

// a stream  ... BehaviorSubject == gleich wie Subject, aber stores the last value
currentUser: Subject<User> = new BehaviorSubject<User>(null);

// a stream that emits an array of the most up to date messages
messages: Observable<Message[]>;

this.bla.subscribe(this.foo);  ...foo listen on bla changes

siehe auch EventEmitter

.subscribe(
        (results: SearchResult[]) => { // on sucesss ... this.loading.emit(false);
        (err: any) => { // on error
        () => { // on completion

.publishReplay(1).refCount();  streams aren’t shareable by default. if one subscriber reads a value... kein anderer kann mehr lesen... Mit dem umgehen

.next(u);  == push a new value to the stream

.scan()  ...it runs the function for each element  (wie reduce) ... creates a new stream.

.map() ..it runs the function once for each item in the stream and emits the return value of the function.

.combineLates() ...2 streams zusammneführen




heroes$: Observable<Hero[]>;
   
Underscore.js...   functional operators auf Array z.B. 
_.sortBy(threads, (t: Thread) => t.lastMessage.sentAt).reverse();
_.map

----------------------redux
immutable, central store of state

state = ALL data is in a single data structure .. for the whole app
store = holds the state.. running the reducer and then keeping the new state
action = userklicks... interface Action { actionType: string; payload?: any; }
reducer = pure function...  combining the old state and the action ..= new state ... interface Reducer<T> { (state: T, action: Action): T; }  Darf alten state nicht verändern.  ...  Object.assign({} ...  kopiert Objekt in neues

we create actions which instruct the reducer on how to generate a new state

Redux itself is powerful enough to use in our applications without Observables

import { Store } from 'redux';  .. ist ein node_module
import { AppStore } from './app.store';

Redux Dev Tools - Chrome Extension  (s.376)

in den sub components hat es weiterrhin variablen
...aber im constructor subscriped er sich beim store... und führt seine Variablen dann nach, wenn store ändert.
...oder führt store nach, wenn etwas ändert ... this.store.dispatch(


----------------------test
npm run test
   
Jasmine-  we can describe our tests and their expectations. 
Karma - Ausführungsumgebung wie Browser


----------------------build
ng build --prod
ng build --target=production --base-href /


dann in dist ordner wechseln 
dort in cmd "now" eingeben... das deployt
https://zeit.co/dashboard

https://dist-5j0b6ivjn.now.sh/




================================================================================================================================================= OLD Angular 1
------------------------------------------------------------------------------------------------OLD (mit mafl)
https://docs.angularjs.org/guide/directive
http://www.w3schools.com/angular/angular_sql.asp
https://www.heise.de/developer/artikel/Single-Page-Anwendungen-Framework-unabhaengig-entwickeln-3633930.html
--------------------------------
emmet integriert in sublime 
div#bla.c1.c2 (tab) --->>  <div id="bla" class="c1 c2"></div>



---- ng-init 
...solte man nicht mehr brauchen
initializes application variables.
ng-init="quantity=1;cost=5"

---- ng-app
defines the root element.. kann div aber auch body.. sein
<div ng-app=""></div> macht, dass alles darin z.B: {{...}} überhaupt von angular interpretiert wird 

---- api
z.B. angular.lowercase($scope.x1);

---- module
...container für app bestandteile wie controllers
var app = angular.module('myApp', []);
erster param zeigt auf ng-app element


---- ng-controller
kontrolliert apps... gehören immer zu einem module
<div ng-app="myApp" ng-controller="myCtrl"> ... man gibt immer beide an beim element.. wie namespace und class
app.controller('myCtrl', function($scope, $http)
dependency == weitere params..z.B: obiges http

/app/ui/ui.controller.js
eine klasse pro template
mit freien funcs


---- $scope
the application object
the binding part between the HTML (view) and the JavaScript (controller)
ist eingtlich das model


---- $rootScope
app.run(function($rootScope) {.

---- ng-bind == Expressions
binding an nicht input controls..setzt innerHTML
{{firstName}}   ==   <span ng-bind="firstName"></span>
..das muss so in $scope-obj enthalten sein
synchronization between the model and the view.

---- form
ganz normal <form>...


---- ui-
<div ui-dynui></div>
...dynui ist eine directive


---- ng-model
binding an diese 4 input controls (input, select, (radio)button, textarea)
gebrauche html5 type="number"...
dasmodel muss nicht vorher definiert sein...wächst selber
immer 2 way bind ... ev noch mit @
Form-State + Input-State: invalid, dirty, touched, error
--{{myForm.myAddress.$valid}}


---- directive
ang hat schon viele built-in z.B:
-- ng-repeat="x in names"
selber machen:  app.directive("myDi", function() {..ctor dann brauchen mit:  <myDi/>
fügt automatisch css-klassen hinzu wie ng-invalid... die man stylen kann: <style> input.ng-invalid { background-color: lightblue;


---- Filters
z.B. grossb.: {{ lastName | uppercase }}
oder: " | orderby.."
beginnen mit pipe
selber machen z.B: app.filter('myFormat',['hexafy', function(hexafy) {..



---- Service
function or object only for this app
hat 30 built in... sie sind meist pendants zu bestehenden js Objekten/Funcs...z.B. window.setInterval... man sollte nicht mehr js dinger brauchen..
z.B. $location
oder $http.get("welcome.htm").then(function (response) {  $scope.myWelcome = response.data;
selber machen z.B.: app.service('hexafy', function() {

---- Event
Für alle normalen js events gibt es ng -pendants z.B: <button ng-click="myFunction($event)">
$event == browser's event object

---- Include
zum auslagern des html
<div ng-include="'myTable.htm'"> 

---- Animate
angular-animate.js
braucht: ng-app="ngAnimate" oder als dependency beim controller ctor
ngAnimate add or removes css classes


---- divers
ng-... === data-ng-... (aber html ist valid)   
es gibt ng-... für jquery show, hide, disable...


---- route
angular-route.js
-das html wird dort reingeladen wo <ng-view> steht
var app = angular.module("myApp", ["ngRoute"]);
app.config(function($routeProvider) {
    $routeProvider
    .when("/", {
        templateUrl : "main.htm"
	controller : "londonCtrl"
    })
    .otherwise({..

---- Filter
https://docs.angularjs.org/api/ng/filter/filter
...ist nicht comparator sondern expression

<div class="row" ng-repeat="result in (inEntity | filter:filterFields).length / 4  | arrayFilter ">
....ist das gleiche wie im JS...
$scope.inEntity2 = $filter('filter')($scope.inEntity, $scope.filterFields);

    $scope.filterFields = function (value) {
      return true oder false;
    };



--------------------------------
Mein ertes angular dings: C:\dev\csharp\DynUI\Edorex.DynUI\App\app\app\ivma

man könnte so machen....
    angular.module('app').controller("IvmaController", function($scope) {

...aber wegen minifier (variablen-Namen verschwinden) und wegen JohnPapa soll man es so machen...
    angular.module('app').controller('IvmaController', ['$scope', '$filter', IvmaController]);
    function IvmaController($scope, $filter) {
--------------------------------


grunt serve verbose
...zeigt auch watches


